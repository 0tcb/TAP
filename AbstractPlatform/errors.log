boogie /smoke /z3opt:smt.RELEVANCY=0 /z3opt:smt.CASE_SPLIT=0 /errorLimit:1 /xml:build/CPU.xml Types.bpl ../Common/Types.bpl ../Common/Cache.bpl CPU.bpl CPUImpl.bpl
Boogie program verifier version 2.3.0.61016, Copyright (c) 2003-2014, Microsoft.
found unreachable code:
implementation launch(eid: tap_enclave_id_t, addr_valid: addr_valid_t, addr_map: addr_map_t, excl_map: excl_map_t, entrypoint: vaddr_t) returns (status: enclave_op_result_t)
{
  var mappings_alias: bool;
  var mappings_alias_o: bool;
  var paddr: wap_addr_t;
  var enclave_regs: regs_t;
  var cache_conflict: bool;
  var paddr#AT#0: wap_addr_t;
  var paddr#AT#1: wap_addr_t;
  var call3formal#AT#alias#AT#0: bool;
  var paddr#AT#2: wap_addr_t;
  var cpu_owner_map#AT#0: owner_map_t;
  var cpu_owner_map#AT#1: owner_map_t;
  var cpu_owner_map#AT#2: owner_map_t;
  var paddr#AT#3: wap_addr_t;
  var cpu_owner_map#AT#3: owner_map_t;
  var cpu_owner_map#AT#4: owner_map_t;
  var call4formal#AT#alias#AT#0: bool;
  var call0formal#AT#regs#AT#0: regs_t;
  var call1formal#AT#conflict#AT#0: bool;
  var tap_enclave_metadata_valid#AT#0: tap_enclave_metadata_valid_t;
  var tap_enclave_metadata_addr_map#AT#0: tap_enclave_metadata_addr_map_t;
  var tap_enclave_metadata_addr_valid#AT#0: tap_enclave_metadata_addr_valid_t;
  var tap_enclave_metadata_entrypoint#AT#0: tap_enclave_metadata_entrypoint_t;
  var tap_enclave_metadata_pc#AT#0: tap_enclave_metadata_pc_t;
  var tap_enclave_metadata_regs#AT#0: tap_enclave_metadata_regs_t;
  var tap_enclave_metadata_paused#AT#0: tap_enclave_metadata_paused_t;
  var tap_enclave_metadata_cache_conflict#AT#0: tap_enclave_metadata_cache_conflict_t;
  var status#AT#0: enclave_op_result_t;
  var cpu_owner_map#AT#5: owner_map_t;
  var tap_enclave_metadata_addr_valid#AT#1: tap_enclave_metadata_addr_valid_t;
  var tap_enclave_metadata_valid#AT#1: tap_enclave_metadata_valid_t;
  var tap_enclave_metadata_addr_map#AT#1: tap_enclave_metadata_addr_map_t;
  var tap_enclave_metadata_entrypoint#AT#1: tap_enclave_metadata_entrypoint_t;
  var tap_enclave_metadata_pc#AT#1: tap_enclave_metadata_pc_t;
  var tap_enclave_metadata_regs#AT#1: tap_enclave_metadata_regs_t;
  var tap_enclave_metadata_paused#AT#1: tap_enclave_metadata_paused_t;
  var tap_enclave_metadata_cache_conflict#AT#1: tap_enclave_metadata_cache_conflict_t;
  var paddr#AT#4: wap_addr_t;
  var paddr#AT#5: wap_addr_t;
  var call3formal#AT#alias#AT#1: bool;
  var paddr#AT#6: wap_addr_t;
  var call3formal#AT#alias#AT#2: bool;
  var paddr#AT#7: wap_addr_t;
  var cpu_owner_map#AT#6: owner_map_t;
  var cpu_owner_map#AT#7: owner_map_t;
  var paddr#AT#8: wap_addr_t;
  var call3formal#AT#alias#AT#3: bool;
  var paddr#AT#9: wap_addr_t;
  var cpu_owner_map#AT#8: owner_map_t;
  var cpu_owner_map#AT#9: owner_map_t;
  var cpu_owner_map#AT#10: owner_map_t;
  var call4formal#AT#alias#AT#1: bool;
  var call0formal#AT#regs#AT#1: regs_t;
  var call1formal#AT#conflict#AT#1: bool;
  var tap_enclave_metadata_valid#AT#2: tap_enclave_metadata_valid_t;
  var tap_enclave_metadata_addr_map#AT#2: tap_enclave_metadata_addr_map_t;
  var tap_enclave_metadata_addr_valid#AT#2: tap_enclave_metadata_addr_valid_t;
  var tap_enclave_metadata_entrypoint#AT#2: tap_enclave_metadata_entrypoint_t;
  var tap_enclave_metadata_pc#AT#2: tap_enclave_metadata_pc_t;
  var tap_enclave_metadata_regs#AT#2: tap_enclave_metadata_regs_t;
  var tap_enclave_metadata_paused#AT#2: tap_enclave_metadata_paused_t;
  var tap_enclave_metadata_cache_conflict#AT#2: tap_enclave_metadata_cache_conflict_t;
  var paddr#AT#10: wap_addr_t;
  var call3formal#AT#alias#AT#4: bool;
  var paddr#AT#11: wap_addr_t;
  var cpu_owner_map#AT#11: owner_map_t;
  var paddr#AT#12: wap_addr_t;
  var call3formal#AT#alias#AT#5: bool;
  var paddr#AT#13: wap_addr_t;
  var cpu_owner_map#AT#12: owner_map_t;
  var cpu_owner_map#AT#13: owner_map_t;
  var paddr#AT#14: wap_addr_t;
  var call3formal#AT#alias#AT#6: bool;
  var paddr#AT#15: wap_addr_t;
  var cpu_owner_map#AT#14: owner_map_t;
  var cpu_owner_map#AT#15: owner_map_t;
  var cpu_owner_map#AT#16: owner_map_t;
  var paddr#AT#16: wap_addr_t;
  var paddr#AT#17: wap_addr_t;
  var call3formal#AT#alias#AT#7: bool;
  var paddr#AT#18: wap_addr_t;
  var cpu_owner_map#AT#17: owner_map_t;
  var paddr#AT#19: wap_addr_t;
  var paddr#AT#20: wap_addr_t;
  var paddr#AT#21: wap_addr_t;


  0:
    goto anon0;

  anon0:
    goto anon24_Else;

  anon24_Else:
    assume {:partition} cpu_enclave_id == tap_null_enc_id;
    goto anon25_Else;

  anon25_Else:
    assume {:partition} !(eid == tap_null_enc_id || tap_enclave_metadata_valid[eid]);
    assert eid != tap_null_enc_id;
    assert !tap_enclave_metadata_valid[eid];
    goto anon26_Else;

  anon26_Else:
    assume {:partition} !(!tap_addr_perm_x(addr_valid[entrypoint]) || !excl_map[addr_map[entrypoint]]);
    paddr := k0_wap_addr_t;
    assert (forall pa: wap_addr_t :: LT_wapa(pa, paddr) && excl_map[pa] ==> cpu_owner_map[pa] == tap_null_enc_id);
    assert (forall pa: wap_addr_t :: LT_wapa(pa, paddr) ==> cpu_owner_map[pa] != eid);
    goto anon27_LoopHead;

  anon27_LoopHead:
    havoc paddr;
    assume {:inferred} cpu_enclave_id == 0;
    assume (forall pa: wap_addr_t :: LT_wapa(pa, paddr) && excl_map[pa] ==> cpu_owner_map[pa] == tap_null_enc_id);
    assume (forall pa: wap_addr_t :: LT_wapa(pa, paddr) ==> cpu_owner_map[pa] != eid);
    goto anon27_LoopBody;

  anon27_LoopBody:
    assume {:partition} LT_wapa(paddr, kmax_wap_addr_t);
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:partition} !excl_map[paddr];
    goto anon10;

  anon28_Then:
    assume {:partition} excl_map[paddr];
    goto anon29_Else;

  anon29_Else:
    assume {:partition} cpu_owner_map[paddr] == tap_null_enc_id;
    goto anon10;

  anon10:
    goto anon30_Then;

  anon30_Then:
    assume {:partition} cpu_owner_map[paddr] == eid;
    status := enclave_op_invalid_arg;
    assert false;
    assert (forall pa: wap_addr_t, e: tap_enclave_id_t :: e != tap_null_enc_id && !tap_enclave_metadata_valid[e] ==> cpu_owner_map[pa] != e);
    assert status != enclave_op_success ==> cpu_owner_map == old(cpu_owner_map);
    assert status != enclave_op_success ==> tap_enclave_metadata_valid == old(tap_enclave_metadata_valid);
    assert status != enclave_op_success ==> tap_enclave_metadata_addr_map == old(tap_enclave_metadata_addr_map);
    assert status != enclave_op_success ==> tap_enclave_metadata_addr_valid == old(tap_enclave_metadata_addr_valid);
    assert status != enclave_op_success ==> tap_enclave_metadata_entrypoint == old(tap_enclave_metadata_entrypoint);
    assert status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc);
    assert status != enclave_op_success ==> tap_enclave_metadata_regs == old(tap_enclave_metadata_regs);
    assert status != enclave_op_success ==> tap_enclave_metadata_paused == old(tap_enclave_metadata_paused);
    assert status != enclave_op_success ==> tap_enclave_metadata_cache_conflict == old(tap_enclave_metadata_cache_conflict);
    assert (forall pa: wap_addr_t :: status == enclave_op_success ==> (excl_map[pa] <==> cpu_owner_map[pa] == eid));
    assert (forall pa: wap_addr_t :: status == enclave_op_success ==> !excl_map[pa] ==> cpu_owner_map[pa] == old(cpu_owner_map)[pa]);
    assert (forall pa: wap_addr_t :: status != enclave_op_success ==> cpu_owner_map[pa] == old(cpu_owner_map[pa]));
    assert (forall e: tap_enclave_id_t :: e != eid ==> (tap_enclave_metadata_valid[e] <==> old(tap_enclave_metadata_valid)[e]));
    assert (forall e: tap_enclave_id_t :: e != eid ==> tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]);
    assert (forall e: tap_enclave_id_t :: e != eid ==> tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]);
    assert (forall e: tap_enclave_id_t :: e != eid ==> tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]);
    assert (forall e: tap_enclave_id_t :: e != eid ==> tap_enclave_metadata_entrypoint[e] == old(tap_enclave_metadata_entrypoint)[e]);
    assert (forall e: tap_enclave_id_t :: e != eid ==> tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]);
    assert (forall e: tap_enclave_id_t :: e != eid ==> (tap_enclave_metadata_paused[e] <==> old(tap_enclave_metadata_paused)[e]));
    assert (forall e: tap_enclave_id_t :: e != eid ==> (tap_enclave_metadata_cache_conflict[e] <==> old(tap_enclave_metadata_cache_conflict)[e]));
    assert cpu_enclave_id == tap_null_enc_id && eid != tap_null_enc_id && !old(tap_enclave_metadata_valid)[eid] && tap_addr_perm_x(addr_valid[entrypoint]) && excl_map[addr_map[entrypoint]] && (forall pa: wap_addr_t :: excl_map[pa] ==> old(cpu_owner_map)[pa] == tap_null_enc_id) && (forall v1: vaddr_t, v2: vaddr_t :: !vaddr_alias(addr_valid, addr_map, excl_map, v1, v2)) && (forall v1: vaddr_t, v2: vaddr_t :: !vaddr_alias_o(eid, addr_valid, addr_map, cpu_owner_map, v1, v2)) <==> status == enclave_op_success;
    assert status == enclave_op_success || status == enclave_op_invalid_arg;
    assert status == enclave_op_success ==> (forall pa: wap_addr_t :: (if excl_map[pa] then cpu_owner_map[pa] == eid else cpu_owner_map[pa] == old(cpu_owner_map)[pa]));
    assert status == enclave_op_success ==> (forall pa: wap_addr_t :: (if excl_map[pa] then cpu_owner_map[pa] == eid else cpu_owner_map[pa] == old(cpu_owner_map)[pa]));
    assert status == enclave_op_success ==> tap_enclave_metadata_valid[eid];
    assert status == enclave_op_success ==> tap_enclave_metadata_pc[eid] == entrypoint;
    assert status == enclave_op_success ==> tap_enclave_metadata_entrypoint[eid] == entrypoint;
    assert status == enclave_op_success ==> !tap_enclave_metadata_paused[eid];
    assert status == enclave_op_success ==> ((exists p1: wap_addr_t, p2: wap_addr_t :: cpu_owner_map[p1] == eid && cpu_owner_map[p2] != eid && paddr2set(p1) == paddr2set(p2)) <==> tap_enclave_metadata_cache_conflict[eid]);
    assert status == enclave_op_success ==> (forall ri: regindex_t :: tap_enclave_metadata_regs[eid][ri] == k0_word_t);
    assert status == enclave_op_success ==> tap_enclave_metadata_addr_valid[eid] == addr_valid;
    assert status == enclave_op_success ==> tap_enclave_metadata_addr_map[eid] == addr_map;
    assert status == enclave_op_success ==> (forall v1: vaddr_t, v2: vaddr_t :: !vaddr_alias(tap_enclave_metadata_addr_valid[eid], tap_enclave_metadata_addr_map[eid], excl_map, v1, v2));
    assert status == enclave_op_success ==> (forall v1: vaddr_t, v2: vaddr_t :: !vaddr_alias_o(eid, tap_enclave_metadata_addr_valid[eid], tap_enclave_metadata_addr_map[eid], cpu_owner_map, v1, v2));
    return;
}



Boogie program verifier finished with 10 verified, 0 errors
